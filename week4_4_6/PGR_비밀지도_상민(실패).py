'''
네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.

지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
"지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.
'''

def change_binary(n, arr):
    for i in range(n):
        # 빈문자열 초기화
        temp = ''
        # 1이면 n-1만큼 0을 앞에 붙이고 마지막에 1을 적어주고 다음 요소 진행
        if arr[i] == 1:
            arr[i] = '0'*(n - 1) + '1'
            continue
        # num에 배열의 해당 요소 할당
        num = arr[i]
        # num이 1 초과일때까지만 반복
        while num > 1:
            # 몫, 나머지
            num, remainder = divmod(num, 2)
            # 나머지를 문자열에 합치기
            temp += str(remainder)
        # 이진법으로 변환할 때 마지막에는 1이 남기 때문에 문자열에 `1` 더하기
        temp += '1'
        # n x n 정사각형이므로 변환한 이진수의 길이가 n이 될때까지 `0`을 더해줌
        while len(temp) < n:
            temp += '0'
        # 마지막에 문자열 뒤집어줘서 이진수 완성
        arr[i] = temp[::-1]

def solution(n, arr1, arr2):
    # 이진수 만들기
    change_binary(n, arr1)
    change_binary(n, arr2)
    # arr1, arr2 각 행 순회하면서
    answer = []
    for k in range(n):
        temp = ''
        a, b = arr1[k], arr2[k]
        for l in range(n):
            # 1이면 1, 0이 두개면 0으로 새로운 square 생성
            if a[l] == '0' and b[l] == '0':
                temp += ' '
            else:
                temp += '#'
        answer += [temp]
    return answer