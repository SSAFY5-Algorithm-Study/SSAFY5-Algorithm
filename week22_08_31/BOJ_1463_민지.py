# 문제 ############################################
# 정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

# 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
# 2. X가 2로 나누어 떨어지면, 2로 나눈다.
# 3. 1을 뺀다.
# 정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다.
# 연산을 사용하는 횟수의 최솟값을 출력하시오.

# 접근법 ############################################
# 1. 그리디하게 접근..? --> 응 아니야.. 실패 ㅠㅅㅠ 
# 3으로 나눌수 있으면 나눈다 --> 2로 나눌수 있으면 나눈다 --> 둘 다 안되면 1을 뺀다

# 2. DP...?
# DP[N] 에 숫자 N을 만들 수 있는 최소 횟수를 저장한다 (ex) DP[2] = 1, DP[5] = 3...
# N이 2 또는 3으로 나누어 떨어지는 숫자인 경우: DP[N/2], DP[N/3]과  DP[N-1]을 비교하여 가장 작은 수에 + 1
# 나누어 떨어지지 않는 경우: DP[N-1] + 1
###################################################

import sys
input = sys.stdin.readline

N = int(input())
DP = [0] * (N+1)

for i in range(2, N+1):
    # 2와 3 둘 다로 나눠 떨어지는 경우
    if i % 6 == 0:
        DP[i] = min(DP[i//3], DP[i//2], DP[i-1]) + 1
    # 3으로만 나눠 떨어지는 경우
    elif i % 3 == 0:
        DP[i] = min(DP[i//3], DP[i-1]) + 1
    # 2로만 나눠 떨어지는 경우
    elif i % 2 == 0:
        DP[i] = min(DP[i//2], DP[i-1]) + 1
    # 아무것도 안되는 경우
    else:
        DP[i] = DP[i-1] + 1

print(DP[N])